#include "ResCppSrcGenerator.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <filesystem>
#include <cctype>

namespace fs = std::filesystem;

namespace resman
{
    //──────────────────────────────
    // Setters
    //──────────────────────────────
    ResCppSrcGenerator& ResCppSrcGenerator::setOutputCppDir(const std::string& path)
    {
        mOutputCppDir = path;
        return *this;
    }

    ResCppSrcGenerator& ResCppSrcGenerator::setResourceInfo(const std::vector<ResourceInfo>& resInfo)
    {
        mResInfo = resInfo;
        return *this;
    }

    ResCppSrcGenerator& ResCppSrcGenerator::setResSearchPath(const std::string& resSearchPath)
    {
        if (!resSearchPath.empty())
            mResSearchPaths.push_back(resSearchPath);
        return *this;
    }

    ResCppSrcGenerator& ResCppSrcGenerator::setResSearchPath(const std::vector<std::string>& resSearchPaths)
    {
        for (const auto& path : resSearchPaths)
        {
            if (!path.empty())
                mResSearchPaths.push_back(path);
        }
        return *this;
    }

    //──────────────────────────────
    // Helpers
    //──────────────────────────────
    bool ResCppSrcGenerator::validateInputs() const
    {
        if (mOutputCppDir.empty()) {
            std::cerr << "[ResCppSrcGenerator] Error: output .cpp directory not set.\n";
            return false;
        }

        if (mResInfo.empty()) {
            std::cerr << "[ResCppSrcGenerator] Error: no resource info provided.\n";
            return false;
        }

        if (!fs::exists(mOutputCppDir)) {
            std::cerr << "[ResCppSrcGenerator] Error: output directory does not exist: " << mOutputCppDir << "\n";
            return false;
        }

        return true;
    }

    std::string ResCppSrcGenerator::sanitizeIdentifier(const std::string& input) const
    {
        std::string sanitized;
        sanitized.reserve(input.size());
        for (char c : input)
        {
            if (std::isalnum(static_cast<unsigned char>(c)))
                sanitized.push_back(c);
            else
                sanitized.push_back('_');
        }
        return sanitized;
    }

    static std::optional<fs::path> resolveResourcePath(const std::string& resourceFile,
                                                       const std::vector<std::string>& searchPaths)
    {
        // Try direct path first
        if (fs::exists(resourceFile))
            return fs::path(resourceFile);

        // Try each search path
        for (const auto& dir : searchPaths)
        {
            fs::path candidate = fs::path(dir) / resourceFile;
            if (fs::exists(candidate))
                return candidate;
        }

        return std::nullopt;
    }

    //──────────────────────────────
    // Core Generation
    //──────────────────────────────
     bool ResCppSrcGenerator::generateCppSource() const
    {
        for (const auto& res : mResInfo)
        {
            auto resolved = resolveResourcePath(res.resFilepath, mResSearchPaths);
            if (!resolved)
            {
                std::cerr << "[ResCppSrcGenerator] Warning: could not locate resource: "
                          << res.resFilepath << "\n";
                continue;
            }

            fs::path filePath = *resolved;
            std::ifstream in(filePath, std::ios::binary);
            if (!in)
            {
                std::cerr << "[ResCppSrcGenerator] Error: failed to read file: " << filePath << "\n";
                continue;
            }

            std::ostringstream buffer;
            buffer << in.rdbuf();
            std::string data = buffer.str();

            // Extract numeric ID from Resource type, e.g., "resman::Resource<1>"
            unsigned id = 0;
            const std::string& type = res.resType;
            auto start = type.find('<');
            auto end = type.find('>');
            if (start != std::string::npos && end != std::string::npos && end > start + 1)
                id = std::stoi(type.substr(start + 1, end - start - 1));

            // Output file = <basename>.cpp
            fs::path cppName = fs::path(res.resFilepath).stem().string() + ".cpp";
            fs::path outputPath = fs::path(mOutputCppDir) / cppName;

            std::ofstream out(outputPath);
            if (!out)
            {
                std::cerr << "[ResCppSrcGenerator] Error: failed to create: " << outputPath << "\n";
                continue;
            }

            out << "// Auto-generated by resman-lite\n";
            out << "#include \"resman.h\"\n\n";
            out << "namespace resman {\n\n";

            out << "    template<>\n";
            out << "const char Resource<" << id << ">::storage_begin[] = {";
            for (size_t i = 0; i < data.size(); ++i)
            {
                if (i % 12 == 0) out << "\n    ";
                out << static_cast<unsigned int>(static_cast<unsigned char>(data[i])) << ",";
            }
            out << "\n};\n\n";

            out << "    template<>\n";
            out << "const unsigned Resource<" << id << ">::storage_size = " << data.size() << "u;\n\n";

            out << "} // namespace resman\n";

            std::cout << "[ResCppSrcGenerator] Generated: " << outputPath << "\n";
        }

        return true;
    }

    //──────────────────────────────
    // Entry point
    //──────────────────────────────
    bool ResCppSrcGenerator::run()
    {
        if (!validateInputs())
            return false;

        return generateCppSource();
    }

} // namespace resman